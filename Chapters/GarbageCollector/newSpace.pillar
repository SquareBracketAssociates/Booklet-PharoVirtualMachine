!!The New Space

!!! New Space Memory Layout

The new space is divided into three areas (cf. Figure *@newSpace*): Eden (5/7 of the new space) and two other areas (1/7 of the new space each) that alternatively play the role of past and future space.
The VM always allocate new objects into the Eden space if there is enough space.

+The New Space Structure>figures/newSpace.pdf|width=100|label=newSpace+

!!!The Scavenger)

The scavenger is a copy-collector responsible to manage the new space memory region.
The scavenger is periodically triggered on some events such as: the eden is full i.e. left space reached a predefined threshold. There are multiple scavenger policies:	
    -TenureByAge: default policy that consists in copying surviving objects either in future space or old space depending on a threshold (cf SpurGenerationScavenger>>shouldBeTenured:). Surviving objects in past space with addresses below this threshold are tenured i.e. copied to the old space instead of future space. Initially, the threshold value is 0 meaning that the scavenger will not tenure any surviving objects, they are copied to future space. At the end of the scavenge, the scavenger updates the treshold if the future space is filled at more than 90%. The next scavenge will then tenure objects.

	-TenureByClass: policy that consists in tenuring objects instance of a specific class.

	-TenureToShrinkRT: policy that consist in tenuring objects in order to shrink the remember table meaning minimizing objects in the old space thath reference objects in the new space.

	-DontTenure: policy that consists in not tenuring objects (i.e. threshold fixed at 0).

	-MarkOnTenure: the full mark and sweep GC of the old space calls the scavenger with this policy. The threshold will be 0.

The VM allocates new objects in the eden space.
When a newly allocated object address in the eden space reaches the scavenge threshold, the scavenger is triggered.
To free some space in the eden, the scavenger does not iterate over all objects it contains.
It computes surviving objects i.e. referenced by ""root objects"".
There are three kind of roots:

- objects referenced in the stack i.e. used as receivers or parameters
- objects stored in the remembered set. This set contains all objects allocated in the old space that contains at least one reference to an object in the new space
- special objects known by the VM such as: nil, true, false, class table, etc.

The scavenger starts by copying roots references allocated into Eden or Past spaces into the future space. 
Then, it traverses these copied objects and copies their referenced objects that resides into Eden or Past space into the future space.
At the same time, traversed references are fixed to correctly reference the copied objects.  
Similarly, root objects references are also updated.
Finally, the future space contains all reachable objects from roots that were present into the Eden and Past spaces.
Moreover, all their references have been updated to correctly point to objects into the future space.
If the future space is filled during the scavenge, some objects are tenured i.e. copied into the old space. 
There are multiple strategies regarding the tenuring of objects:

- By age, using the addresses in the past (older objects have smaller the addresses)
- Tenure to shrink the remembered table, it is used when the remembered set is too big
- Instances of a given class, it is used by the ==someInstance== primitive before its execution making all instances available into the old space. 

Once the scavenge is finished, the future and past spaces are switched; it just means that the future space is now considered as the Past space and vice-versa.


!!!!Example of a Scavenger Pass 

[[[
Roots references: A, C

B -> D
C -> A
A -> B
A -> C
E
]]]

- Step 1: copy roots references
future space: A, C

- Step 2: We go over first surviving object (A)
future space: A, C, B
(C was already copied, so we just update the reference)

- Step 3: We go over second surviving object (C)
future space: A, C, B
(C points to A, but A was already copied, so we just update the reference)

- Step 4: We go over next surviving object (B)
future space: A, C, B, D

- Step 5: We go over next surviving object (D)
Nothing to do, and nothing new in future space

- Step 6: exchange past and future spaces