!!Memory Structure and Garbage Collection

!!!Memory Structure

The memory map maintained by the VM is depicted on Figure *@memoryMap*.

+Memory Map>figures/memoryMap.pdf|width=100|label=memoryMap+

The Stack (both Pharo and C) resides in the lower address of the memory.
This is the stack used by the C Code and also the stack pages are allocated in this stack.
All the execution of a process stores the information in the stack.
The stack is the real representation of the contexts in the image. 
The frames are in a sequence, in the stack. 
Each frame knows the calling frame with a pointer. 
Objects referenced into stack frames are retained i.e. never garbage collected.

The young space (also called new space) is used by the VM to create objects and manage short-life objects.
The old space contains objects that survived longer. 

Statistics shows that new objects die faster than older ones, therefore many objects will be discarded fastly.
This is why the Pharo VM uses two different Garbage Collectors (GCs).
The ""Scavenger"" (a copy garbage collector) manages objects allocated into the new space area.
We call ""scavenge"" the operation of recovering space in the new space only.
The old space is managed by a compacting garbage collector.
This garbage collector is slower and run less often than the scavenger but the new space is also much smaller than the old space.

Note that when saving the image, only the old space is saved. 

In Pharo, the __TimeProfiler__ tool can report on memory usage metrics and GCs passes. 
For example, the execution of this expression:

[[[
[ 10000 timesRepeat: [ Object new ] ] timeProfile
]]]

produces this report:

[[[
**Memory**
	old			+0 bytes
	young		-4,956,688 bytes
	used		-4,956,688 bytes
	free		+4,956,688 bytes
]]]

It means that only young space has been used and freed.
It is obvious because no references to these newly created objects have been stored.

!!! APIs

The VM has two different APIs to manipulate the memory: one that will fail if there is no memory and the other one that will execute a scavenge or a full-GC if needed.

!!!The New Space

The new space is divided into three areas (cf. Figure *@youngSpace*): Eden (5/7 of the new space) and two other areas (1/7 of the new space each) that alternatively play the role of past and future space.
The VM always allocate new objects into the Eden space.

+The New Space Structure>figures/youngSpace.pdf|width=100|label=youngSpace+

!!!The Scavenger

The scavenger is periodically triggered on some events such as: the eden is full i.e. left space reached a predefined threshold.
There are multiple scavenger policies but the main one consists in emptying the eden space by copying surviving objects (i.e. still reachable objects from ""root objects"") into the future space. 
If the future space is full (or reached a threshold) during the scavenge, some objects are ""tenured""  i.e. transferred into the old space.

The scavenger does not iterate over all objects into the Eden space.
Instead, the scavenger iterates over all the ==root objects==. 
A root retains the objects it references.
There are three kind of roots:

- objects referenced in the stack i.e. used as receivers or parameters
- objects stored in the remembered set. This set contains all objects that are in the old space and contain at least one reference to an object in the new space
- special objects known by the VM such as: nil, true, false, class table, etc

The scavenger starts by copying roots references allocated into Eden or Past spaces into the future space. 
Then, it traverses these copied objects and copies their referenced objects that resides into Eden or Past space into the future space.
At the same time, traversed references are fixed to correctly reference the copied objects.  
Similarly, root objects references are also updated.
Finally, the future space contains all reachable objects from roots that were present into the Eden and Past spaces.
Moreover, all their references have been updated to correctly point to objects into the future space.
If the future space is filled during the scavenge, some objects are tenured i.e. copied into the old space. 
There are multiple strategies regarding the tenuring of objects:

- By age, using the addresses in the past (older objects have smaller the addresses)
- Tenure to shrink the remembered table, it is used when the remembered set is too big
- Instances of a given class, it is used by the ==someInstance== primitive before its execution making all instances available into the old space. 

Once the scavenge is finished, the future and past spaces are switched; it just means that the future space is now considered as the Past space and vice-versa.


!!!!Example of a Scavenger Pass 

[[[
Roots references: A, C

B -> D
C -> A
A -> B
A -> C
E
]]]

- Step 1: copy roots references
future space: A, C

- Step 2: We go over first surviving object (A)
future space: A, C, B
(C was already copied, so we just update the reference)

- Step 3: We go over second surviving object (C)
future space: A, C, B
(C points to A, but A was already copied, so we just update the reference)

- Step 4: We go over next surviving object (B)
future space: A, C, B, D

- Step 5: We go over next surviving object (D)
Nothing to do, and nothing new in future space

- Step 6: exchange past and future spaces

!!!The Old Space

At startup, the VM allocates a memory map as depicted on Figure *@youngSpace*.
The initial old space has only one segment but it can then vary dynamically by allocating and freeing segments.
Figure *@oldSpace* shows an example of an old space with two segments.

+The Old Space Structure>figures/oldSpace.pdf|width=100|label=oldSpace+

The first segment of the old space stores at least these objects:

- nil
- true
- false 
- classTable i.e. an array of all the classes in the image; in its header, an object does not directly store a reference to its class but the index of its class in this table.
- remember set
- freeTree
- freeLists
- bridge byte array
