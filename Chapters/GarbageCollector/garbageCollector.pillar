!!Understanding Memory Structure and Garbage Collection  

!!!Memory Structure

The memory map of the image is the following.

+Memory Map>figures/memoryMap2.pdf|width=100|label=memoryMap+

In the lower address of the memory there is the Stack (both Pharo and C), this is the stack used by the C Code and also the stack pages are allocated in this stack.
Then, the new space is divided in three areas: Eden (5/7 of the new space) and two other areas (1/7 of the new space each) that alternatively play the role of past and future space.

!!!Two different Garbage Collectors

The new space area is managed by a generational garbage collector called the scavenger.
We call ""scavenge"" the operation of recovering space in the new space only.
New objects are always allocated in the eden space.
The scavenger is then periodically triggered on some events such as: the eden is full (reached a predefined threshold in fact).
There are multiple scavenger policies but the main one consists in emptying the eden area by copying surviving objects (still reachable from root objects) in the future space. 
If the future space is full (or reached a threshold) during the scavenge, some objects considered as old are transferred in the old space. 

The old space is managed by a compacting garbage collector.
This garbage collector that is run less often than the scavenger.

!!!The scavenger

When triggered, the scavenger does not iterate over all objects in the eden space.
Instead, the scavenger iterates over all the root objects. 
The following objects as used as roots: 

- The stack of the processes running in the image
- The remembered set (i.e. the set of all objects that are in the old space and have references to objects in the new space)

All objects directly referenced by roots are copied into the future space. 
Then, these copied objects are also traversed to copy their referenced objects into the future space and fix their references at the same time.
Indeed, since object are copied in memory, all root objects references must be changed to correctly reference object in the future space.
If during the copy to the future space the objects does not fit, they are copied to the old space. 
Once the scavenge is finished, the future and past spaces are switched.

!!! API

The VM has two different API to manipulate the memory: one that will fail if there is no memory and the other that will execute a scavenge or a full-GC if needed.