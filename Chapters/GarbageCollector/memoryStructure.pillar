!! The Spur Memory Manager Overview

The Pharo virtual machine implements an object memory manager named Spur.
An object memory manager is a memory manager whose allocation units are objects.
In contrast to the operating system memory manager that manipulates raw memory, the Spur memory manager manipulates only objects.
For example, the lowest-level allocation operation is to allocate an object specifying the desired number of slots, format and class index.
We saw in the previous chapters the object format, and what these three arguments mean.

[[[smalltalk
memoryManager
  allocateSlots: numberOfSlots
  format: instanceSpecification
  classIndex: classIndex
]]]

The virtual machine tracks the life-cycle of all objects it allocates.
The memory manager implements an automatic garbage collection mechanism.
It detects when an object has no more incoming references, and deallocates it.
The garbage collector of Spur is precise and generational.
It is precise because it distinguishes non-ambiguously object pointers from random memory adresses.
It is generational because it categorizes objects ''by age'', treating them differently depending on their age.

In this chapter we do an overview of the Spur memory manager, and the concepts behind it.
We will study how the memory is organized, how object generations impacts this organization, and how objects grow old in this generational setup.

!!! Memory Structure Overview

The Spur memory manager layouts its memory in two main sections: the new space and the old space.
The new space contains objects considered young i.e., objects that have been recently created.
The old space contains objets that did survive in the new space for some time, and were promoted as adults in the old space.

At startup, the memory manager requests the operating system a chunk of raw memory to store the new space and the old space.
The memory manager uses the first part of this memory as the new space, and the rest as old space.
Figure *@memoryMap* depicts how the two spaces are laid-out in memory, considering that lower addresses are at the left, and higher addresses are at the right.

+Memory Map: a new space followed by an old space.>figures/memoryMap.pdf|width=100|label=memoryMap+

Addresses in the new space are lower than those in the old space.
This way, the VM easily determines if an object is old or young by comparing its address against the limit of the new space.
The memory manager stores the limits of the new space as ==newSpaceStart== and ==newSpaceLimit==. It defines that an object is young if its address is less than the new space limit.

[[[smalltalk|caption=A young object is an object located below the newSpaceLimit
memoryManager newSpaceStart.
memoryManager newSpaceLimit.

SpurMemoryManager >> isYoung: oop
	<api>
	"Answer if oop is young."
	^(self isNonImmediate: oop)
	  and: [self oop: oop isLessThan: newSpaceLimit]
]]]

!!!Memory Growing and Segments

The new space remains fixed once initialized i.e., it does not grow after its allocation.
On the contrary, the old space is organized in one or more memory segments, and it can grow dynamically by adding new segments to it.
The new space and first segment of the old space are allocated in single contiguous chunk of memory as we have seen above.
Newly added segments do not require to be contiguous, but they need to be at higher addresses than the first segment.

When a new segment is added, a bridge is added to the end of its previous segment.
A bridge is a fake object that fills the gap between the two segments.
Bridge objects have the format of a byte array simulating a size equals to the gap between the two segments.
They give the Spur memory manager and its garbage collector the illusion of an old space made of a single contiguous chunk of memory.
Bridge objects are not visible from the program and do not move during garbage collection.


!!!Memory Initialization

When the virtual machine starts, it requires memory from the operating system to store both the new space and the first segment of the old space.
The size of the new space is computed from a parameter stored in the image file header.
The image file, storing all objects in previous sessions, is loaded into the first segment of the old space.
The size of this first segment is computed as the addition of the image size and a free space headroom to fit objects coming from the new space.

!!!Spur Generational Garbage Collection

Spur implements a generational automatic garbage collector based on an heuristic named the generational hypothesis.
The generational hypothesis states that most objects die young, specially true in highly-interactive applications, so young objects are stored separately than old objects.
This is why the Pharo VM uses two different garbage collector algorithms: one for new objects implementing a generation scavenger, and one for old objects implementing a mark and compact.

The memory manager allocates by default objects in the new space.
When the new space has little space left, it is garbage collected using a copy collection algorithm named generation scavenger, that we will explore in detail in a following chapter.
The new space is much smaller than the old space, so garbage collecting it is fast, producing unnoticeable application pauses.
If the generational hypothesis holds, unused young objects are reclaimed shortly after their instantiation and never moved to the old space.

Objects that are not reclaimed during a garbage collection are called ''survivors''.
As objects survive several new space garbage collections they grow old.
Eventually, objects old-enough are ''tenured'': they are moved to the old space.
The old space is several times bigger than the new space, thus garbage collecting it is expensive and creates long application pauses.
Most objects are collected during new space collections, so collect the old space is not often required.

When the old space has little space left, a mark and compact collection algorithm reclaims unused objects. This algorithm first marks all used objects, and then scans the entire old space freeing unmarked objects and compacting the memory.

!!!The Stack
The stack (both Pharo and C) resides in the lower address of the memory.
This is the stack used by the C code and also the stack pages are allocated in this stack.
All the execution of a process stores the information in the stack.
The stack is the real representation of the contexts in the image. 
The frames are in a sequence in the stack. 
Each frame knows the calling frame with a pointer. 
Objects referenced into stack frames are retained i.e., never garbage collected.

!!! Conclusion

We sketch a first overview of the memory architecture of Pharo.
