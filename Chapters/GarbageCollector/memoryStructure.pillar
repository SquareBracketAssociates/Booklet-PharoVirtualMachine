!!Memory Structure and Garbage Collection

The Spur virtual machine implements an object memory manager.
An object memory manager is a memory manager whose allocation unit are objects.
In contrast with the operating system memory manager that manipulates raw memory, the Spur memory manager manipulates only objects.
For example, the lowest-level allocation operation is to allocate an object specifying the desired number of slots, format and class index.
We will study in subsequent chapters the object format, and what these three arguments mean.

[[[smalltalk
memoryManager
  allocateSlots: numberOfSlots
  format: instanceSpecification
  classIndex: classIndex
]]]

The virtual machine tracks the life-cycle of all objects it allocates.
The memory manager implements an automatic garbage collection mechanism.
It detects when an object has no more incoming references, and deallocates it.
The garbage collector of Spur is precise and generational.
It is precise because it distinguishes non-ambiguously object pointers from random memory adresses.
It is generational because it categorizes objects ""by age"", treating them differently depending on their age.

In this chapter we do an overview of the Spur memory manager, and the concepts behind it.
We will study how the memory is organized, how object generations impacts this organization, and how objects grow old in this generational setup.

!!! Memory Structure Overview

The Spur memory manager layouts its memory in two main sections: the new space and the old space.
The new space contains objects considered young i.e., objects that have been recently created.
The old space contains objets that did survive in the new space for some time, and were promoted as adults in the old space.

At startup, the memory manager requests the operating system a chunk of raw memory to store the new space and the old space.
The memory manager uses the first part of this memory as the new space, and the rest as old space.
Figure *@memoryMap* depicts how the two spaces are laid-out in memory, considering that lower addresses are at the left, and higher addresses are at the right.

The new space and the old space are contiguous: the old space starts where the new space ends.
This way, the VM easily determines if an object is old or young by comparing its address against the limit of the new space.
We can query the memory manager for the limits of the new space using the ==newSpaceStart== and ==newSpaceLimit== messages.

[[[smalltalk
memoryManager newSpaceStart.
memoryManager newSpaceLimit.
]]]


On the one hand, the new space is fixed and does not grow after it is allocated.
On the other hand, the old space is organized in segments, and it grows by allocating new segments on demand.

!!! New Space Overview

+Memory Map>figures/memoryMap.pdf|width=100|label=memoryMap+

The young space (also called new space) is used by the VM to create objects and manage short-life objects.
The old space contains objects that survived longer. 

Statistics shows that new objects die faster than older ones, therefore many objects will be discarded fastly.
This is why the Pharo VM uses two different Garbage Collectors (GCs).
The ""Scavenger"" (a copy garbage collector) manages objects allocated into the new space area.
We call ""scavenge"" the operation of recovering space in the new space only.
The old space is managed by a compacting garbage collector.
This garbage collector is slower and run less often than the scavenger but the new space is also much smaller than the old space.

Note that when saving the image, only the old space is saved. 

When the VM starts, it requires memory from the operating system to store all objects from the read image.
In addition, it asks memory for the new space, plus some headroom to allocate objects in the old space.

!!! Segments Management

!!! The Stack

The Stack (both Pharo and C) resides in the lower address of the memory.
This is the stack used by the C Code and also the stack pages are allocated in this stack.
All the execution of a process stores the information in the stack.
The stack is the real representation of the contexts in the image. 
The frames are in a sequence, in the stack. 
Each frame knows the calling frame with a pointer. 
Objects referenced into stack frames are retained i.e. never garbage collected.

!!! APIs

The VM has two different APIs to manipulate the memory: one that will fail if there is no memory and the other one that will execute a scavenge or a full-GC if needed.
