## Understanding the Spur Memory ModelBefore delving inside the internals of the VM execution, it is important to understand the data it manipulates, in our case, Pharo objects.This chapter presents in-depth how objects are represented in memory.This will allow us understand in further chapters how are created and mutated, how dynamic type checks are performed and the different memory optimizations employed.The Pharo VM uses since a couple of years the Spur memory model, designed and implemented by Eliot Miranda for the OpenSmalltalk VM\(cite\).This model greatly improved the Garbage Collector \(GC\) and the complexity of JIT-compiled machine code.### BackgroundThis section sets up some terminology necessary to understand this chapter, such as *word*, *nibble* or *alignment*.It is important to set up a common vocabulary because some of these terms are used differently by different technologies, and the Pharo VM terminology is not an exception.#### Data Units: Words and BytesObjects are stored in memory, thus it is important to understand the basics of memory organization.Such an organization depends on the chosen computer architecture, which encompasses the memory and the processor.One trait that characterizes a computer architecture and influences strongly the memory organization is its *bit width* *i.e.,* the number of bits used to represent the main processing unit in a processor.For example, 64bit machines are machines with 64bit *width*.Since most common machines nowadays are 64bit machines, we will focus our presentation on them.However, the Pharo VM supports also 32bit machines for compatibility with smaller devices.![Word size and Alignment on 32 and 64 bits architectures.](figures/architecture32vs64.pdf width=100&label=32vs64Architectures)Memory is conceptually divided in cells of 1 byte length, each byte using 8 bits.Data is manipulated in units that group many bytes together.For example, a *word* is a fixed unit of data with as many bits as the processor bit width.This means a word is 64 bits long --or 8 bytes long-- in 64bit processors, and 32 bits long --or 4 bytes long-- in 32bit processors.Figure *@32vs64Architectures@* shows the memory layout on both 32 and 64 bits architectures.The main difference between these two architectures is their word size.Each memory cell has an address represented in a *word*.Note that Figure *@32vs64Architectures@* only shows aligned addresses wheras each 1-byte length cells also have an address.On 64-bits, we may have up to 2^64 different addresses, thus it can address 2^64 different bytes.Representing memory addresses as data is what is commonly referred to as pointers.Processors usually define also concepts such as *half-word*, *double-word*.We believe that such notations are confusing because they require context (Am I in a 32bit architecture? 64bit?), and thus we will not use them in this book.Instead, when referring to a sub-word unit, we will use the exact number of bits.For example, we will use to *16bit integer* instead of *short* or *half-word*.#### AlignmentModern architectures and micro-architectures (how CPUs are implemented internally) behave better when data-access patterns are consistent and predictable.One of such access patterns is data alignment, its relative position in memory.A processor's ISA (Instruction Set Architecture) generally provides instructions to perform data reads and writes with different granularity.There are, for example, instructions to read/write individual bytes or entire words.An read/write is said to be aligned when the address is a multiple of the accessed element size, in bytes.1-byte reads are always aligned because all addresses are multiples of 1.8-byte reads are aligned when the address is multiple of 8.We will see later in this chapter how the Pharo VM exploits alignment to implement tagged pointers, and optimize the read of object header meta-data.#### Most and Least Significant Bytes and BitsValues is memory are physically stored in order.We say that the **most significant** bit is the bit that has most value in a byte, and conversely for the **least significant** bit.Similarly, we can identify the most and least significant bytes in a word.For example, the bit string 00000101 represents the number 5 in binary, and its least significant bit is represented by the rightest bit with value 1.While we usually represents bytes stored from left-to-right this is only the case of some architectures, which luckily for us, turn out to be the most popular nowadays.The order in which bytes are stored is again a trait of the computer architecture: the endianness.An architecture is said to be little-endian if data bytes are stored from the least signicant to the most significant, and big-endian otherwise.### Object LayoutPharo programs are made of objects which are, for the most part, allocated in memory and occupy space.We call these objects *heap-allocated* because they reside in a memory region managed by the VM called the *heap*, that we will explore in later chapters.#### Object Formats@sec:formatsObjects in Pharo are of many different kinds, determining the number of slots they contain and how their slot contents is interpreted.The following table summarizes the most common type of objects and their variations.| Type/Format    | # of slots | Slot type       | Size of slot    | Variations || -------------- | --------------- | --------------- | --------------- | ---------- || Fixed          | fixed           | reference       | word            | Ephemerons || Variable       | variable        | reference       | word            | Weak       || Byte indexable | variable        | byte            | 1/2/4/8 bytes   | -          || CompiledMethod | variable        | reference+byte  | word + 1 byte   | -          |**Fixed and variable slots.** The number of slots in an object is either fixed, variable or a combination of both.Fixed slots are those decided statically. For example, an instance of class `Point` declaring variables `x` and `y` has two fixed slots.Variable slots are those determined at allocation time. The simplest example of variable slot are arrays, whose number of slots is specified as argument of the method `new:`.Some objects may contain a combination of fixed and variable slots, as it is the case of the instances of `Context`. **Slot type.** Slots contain either object references or plain data bytes.Object references are pointers that reference other objects forming a graph, further explained in *@sec:references@*.Plain data is stored as raw bytes in a slot, typically representing low-level data-types such as integers or floats.**Slot size.** The different slots in an object have a size that limits their contents.Reference slots store an address, and thus are a word long.Byte slots store a sequence of bytes, and thus element size can be 1, 2, 4 or 8 bytes.All fixed slots in an object are of type reference.All variable slots in an object are of the same type, and are defined by its class.For example, instances of the class `ByteArray` have 1 byte slots, instances of `FloatArray` have 8 byte slots containing IEEE-754 double precision floating point numbers.**Weak and Ephemeron.** Weak and Ephemeron object formats are variations of the types described above, extending them with special semantics for the memory manager.Weak objects are objects whose variable slots work as weak references~(in contrast with strong references). That is, they don't prevent the garbage collection of the referenced object.Ephemeron objects are fixed objects representing a key-value mapping whose value is referenced strongly as long as the key is referenced by objects other than the ephemeron.These special objects will be further discussed in the chapters about memory management.**CompiledMethod.** Compiled methods are variable objects that do not follow the conventions above.They contain a word sized variable part storing object literals, followed by a 1-byte variable part storing *bytecode*.#### Representing Objects in MemoryObjects in Pharo are represented as a contiguous memory region with space for a header and data slots.The header contains meta-data used for decoding the object internals, such as the size, its type and its class.The data slots contain the object slots.Figure *@fig:objectLayout@* illustrates the layout of a 3 slot object in both 32 and 64 bits.![Object Layout and Alignment on 32 and 64 bits Architectures.](figures/objectLayout.pdf width=90&label=fig:objectLayout)Each object has a mandatory base header that contains common information such as its class, its size and mutable bits for the Garbage Collector.When objects are more than 254 words long, they are considered large, and their actual size is stored in an extra header that precedes the base header.The base and extra headers have each a fixed size of 8 bytes \(64 bits\).Headers are discussed in-depth in *@sec:header@*.Data slots contain the different slots in an object.However, there is not a one-to-one mapping between an object slots and its underlying data slots.Data slots are always 1 word long each and their number is chosen to accommodate all the slots of the object.Each reference slot occupies one data slot.Byte slots, however, may occupy less than a data slot.For example, in a 64bit system a data slot can accommodate 8 1-byte-long slots, 4 2-byte-long slots, 2 4-byte-long slots or 1 8-byte-long slots.A special case arises when byte slots do not entirely fill an object data slots.For example, a 3 slot byte array occupies 3 bytes in a word-long data slot.In such a case, the Pharo VM introduces padding: extra filling space.Such unused filler is used to guarantee that the next object is aligned to the 8-byte boundary, property that can be exploited for both performance and the representation of immediate objects explained in Section *@sec:alignment@*#### References and Ordinary Object Pointers@sec:referencesObjects reference each other forming a directed graph.Nodes in the graph are objects themselves, edges in the graph are usually called *object references*.In the Pharo VM, object references are called *ordinary object pointers*, or *oop*s for short.There are two kind of oops: object pointers to other objects and immediate objects.Pointers work as normal pointers in low-level languages.Immediate objects are objects encoded in invalid object pointers using a technique called tagged pointers that takes advantage of pointer alignment.Every object in Pharo has an address in memory, which is the memory address of its base header.An object `A` references an object `B` with an absolute pointer to `B`'s base header stored in one if `A`s reference slots.Figure *@references@* shows two objects forming a cycle. Each object has a single reference slot pointing to the other.References point to the object base header.![References to heap-allocated objects are pointers to an object's base header.](figures/references.pdf width=90&label=references)### Immediate ObjectsThe object representation presented so far imposes a non-negligible overhead on small objects, because of the space take by its header.This problem becomes more visible with types that tend to have a large number of instances.Integers, for example, are in theory infinite, and are used very often by even the simplest programs to drive the execution of loops.Representing integer objects as heap allocated pointers very fast becomes a bottle neck in an application.Instead, Pharo uses a common optimization called tagged pointers to rerpesent integers and other common simple-valued immutable objects of the like.#### Alignment and Padding@sec:alignmentPointer tagging exploits the alignment property of pointers.In the Pharo VM, all objects are stored in memory aligned to 8 bytes.That is, an object address, and thus its header, is stored always at the 8 byte boundary, regarless of the architecture.Note that since an object header is always 8 bytes long, this means that the first data slot of an object is also always aligned.Further, since all data slots are a word long, each subsequent data slot is also aligned too.To guarantee that objects always are aligned to the 8 byte boundary, the allocator inserts a padding at the end of an object filling it up to the next 8-byte boundary.This happens in two cases: byte objects in general and potentially all objects in 32 bits architectures.Byte objects may contain a number slots that does not entirely fill a data slot, as shown in section *@sec:formats@*, thus requiring padding to fill a data slot.Moreover, data slots in 32bit architectures are 4 bytes long, and thus an odd number of data slots requires an extra 4-bytes of padding.Figure *@fig:objectLayout@* shows an example of an how an object with 1 header and 3 slots in laid out both in 32-bits and 64-bits architectures.- in 64-bits, the object occupies 4 words, for a total of 32 bytes. 1 base header of 8 bytes, 3 slots of 1 word each. The next free address \(32 on the Figure\) is aligned and thus an object can start there.- in 32-bits, the object occupies 5 words, for a total of 20 bytes: 1 base header of 2 words \(8 bytes / 4 bytes per word\), 3 slots of 1 word each. The next free address \(20 on the Figure\) is not aligned. In this case, the allocator inserts a 4 byte padding to align the following object to the 8 byte boundary.Padding represents wasted memory and could be avoided in 32bit architectures by requiring an alignment to a word.However, enforcing the same alignment in all architectures allows an overall code simplification by unifying the 64bit and 32bits implementations.#### Pointer Tagging@sec:taggingPointer tagging is a technique to represent a set of values without the need to perform a allocation.Pointer tagging works by encoding (and disguising) such values within pointer.Such technique is possible thanks to object alignment.Since all Pharo objects are aligned to 8 bytes, all object references will be multiple of 8 and have the form `xxx...xxx000` in binary, where its 3 lower bits are zero.Pointer tagging exploits this property by encoding data within the least significant bits of a pointer.With these three extra bits we can encode up to 7 different tags (111, 110, ... 001) that tell us how to interpret the most significant bits.The main advantage of this technique is to save storage space for common objects, which indirectly improves on data locality and CPU cache behaviour.Its main drawback is an extra runtime cost incurred by runtime type checks: we need to verify if a pointer is tagged or not before operating on data.Another consideration for tagged pointers is that they significantly reduce the number of values that can be represented.For example, tagged integers in the described schema have a maximum precision of 61 bits (+ 3 bits of tag = 64 bits).In the following sections we explain variable-sized tags and boxed values.Variable-sized tags help us mitigate this problem in 32bit architectures, in which the loss is of 10% (3 bits out of 32).Moreover, a combination of pointer tagging and boxed values help us representing larger numbers by assuming that such larger numbers will be less common.Currently, Pharo supports integers, characters and floating point numbers as immediate objects.In 64 bits they use the tags `001`, `010` and `100` respectively, as shown in Figure *@fig:64bitsimm@*.In 32 bits floats are not represented as immediate objects, integers present a 1 bit tag `1` while characters are represented with the 2 bit tag `10`, as shown in Figure *@fig:32bitsimm@*.![64 bits immediate objects.](figures/64bitsImmediate.pdf width=100&label=fig:64bitsimm)![32 bits immediate objects.](figures/32bitsImmediate.pdf width=100&label=fig:32bitsimm)#### Immediate Characters and Integers in 64bitsIn 64 bits, all immediate objects are represented as 61 bits of value and 3 bits of tag.In Pharo, Immediate integers are instances of the class `SmallInteger`, and immediate characters are instances  of the class `Character`.`SmallInteger` immediate objects range is between \[-2^60,2^60-1\] and are represented in two complement.For example, the binary value `2r1010001` represents the untagged value `2r1010` which has the decimal value `10`.```caption=On 64 bits, SmallInteger are encoded on 61 bits.SmallInteger minVal == (2**60) negated>>> trueSmallInteger maxVal == (2**60-1)>>> true```Immediate characters encode in the 61 value bits the character's unicode codepoint.This is, so far, enough to represent all unicode codepoints: the maximum valid codepoint nowadays is 16r10FFFF, which requires only 21 bits.#### 32bit Immediate Integers and Variable TagsIn 32 bits architectures using 3 bits of tag would leave 29 bits left to represent integers.Instead of choosing this fixed tag representation, the 32 bit VM uses variable tagging.That is, different values use different number of bits for tagging.Thus, tagging is carefully designed to avoid conflicts and ambiguities.Immediate integers are tagged with a single bit and use the remaining 31 bits to encode a signed integer in two complement.The range of immediate integers is \[-2^30,2^30-1\]. For example: `2r10101` represents untagged binary number `2r1010` which has the decimal value `10`.Figure *@fig:32bitsimm@* illustrates the entire 32bit tagging schema, with tag bits grayed out:- `00` is an aligned address and therefore an object pointer in the heap.- `*1` tag immediate integers.- `10` tag immediate characters.#### 64bit Immediate FloatsIn 64bit architectures, the Pharo VM represents floats as immediate objects with the tag `100`.The tagged value is an IEEE-754 64bit double-precision floating point number accomodated in 61 bits.However, to accommodate the 64 bits into 61 bits, immediate floats give up 3 bits in the exponent offset, storing only 8 out of 11 bits of exponent.The VM verifies that only immediate floats that do not lose information in this format are encoded as immediates.For floats that do not satisfy this constraints floats use a boxed representation as explained in *@sec:boxing@*.![64 bits `SmallFloat` immediate.](figures/64bitsFloatImmediate.pdf width=100&label=fig:64bitsfloatimm)Figure *@fig:64bitsfloatimm@* shows the structure of a `SmallFloat`.The sign bit is moved the the lowest bit of the tagged value, the highest 3 bits of the exponent are lost.#### Boxed Native Objects@sec:boxingNumbers that cannot be encoded as immediates need to either gracefully fail or implement a fallback mechanism.After arithmetics, if a number does not fit in the 61 bits of a tagged pointer the runtime creates a boxed object with the result.Boxed numbers are byte objects that contain the native number encoded in its byte slots.Boxed numbers in Pharo include large integers (instances of `LargePositiveInteger` and `LargeNegativeInteger`) and boxed floats (instances of `BoxedFloat64`).Large integers implement variable size integers and represent arbitrary large integers as a string of bytes.Boxed floats are instead of fixed size: they represent IEEE-754 double precision floating point numbers, and store 8 bytes the corresponding float.### Object Header@sec:header#### Base Object Header StructureFor objects that are not immediate, a reference always points to an object's base header.A base object header is 64 bits length, which means it is 2 words in 32 bits and 1 word in 64 bits as shown in Figure *@fig:objectheader@*.![Base Object Header.](figures/ObjectHeader.pdf width=100&label=fig:objectheader)Let us explain the object header structure:- The first left topmost 8 red/orange bits \(marked with an `s`\) represent the number of instance variables \(or slots\) in the object. When an object is created and that it owns more than 254 slots, then an additional 64 bits word is allocated as an header extension. The header extension is allocated before the base object header still, all references to the these point to the address of the base object header. This extension encodes directly the number of slots contained by the object. When an object in memory is decoded, if these 8 bits represent 255, the VM knows that there is an header extension. It then reads the 64 bits word located before the object address and decodes it.- The 22 `h` marked top right light blue bits are for the object identity hash.- The 5 `o` pink bottom left marked bits represent object formats as we will explain later.- The 22 `c` yellow bottom right bits are for the class index. In Spur, there is a class table where each class is given an index. Each object stores in those bits the table index of its class.- The 7 green `X` marked remaining bits are allocated for different reasons:  - 1 bit is reserved for immutability.  - 1 bit is reserved to mark the object as pinned. Basically, a pinned object is an object that cannot be moved in memory by the GC.  - 3 bits are reserved for the GC: isGray \(for tri-color marking\), isRemembered \(for the remembered table from old space to young space\) and isMarked \(for the GC mark phasis\).  - 2 bits are free.#### Class Table and Class IndexesAn object do not store a direct reference to its class but the index of its class in its header.Looking up the class associated to the class index for each message send would clearly be dramatic for the VM efficiency.To mitigate this penalty:- The index of class in the class table is its identity hash. Both the class identity hash and class index are 22 bits length.The additional benefit is that every class has a different identity hash: there is no clash possible.- The class table is a linked list of pages, with a class list on each page.The VM puts most common classes on the first page to avoid walking over all the pages to fetch an object's class.- The class index does not change over time. It means that optimisations such as the inline cache can directly compare class indexes.#### Large Objects and the Extra Object HeaderIn some circumstances, an object may have an extra header word.As explained above, the header of an object encodes its number of slots on one word. Therefore, if an object has more than 255 slots, an extra header is required to encode the number of slots within this object.The optional extra-header is always located before the base header in memory.This layout avoid systematically testing the presence of the extra-header.!!note The address of an object is always the one of its base header regardless if it has an extra header or not.#### Object format@formatsThe object format is represented by the 5 pink bits \(marked with `o`\) of the object header.It encodes the following information:- `0` : 0 sized objects - `nil`, `true`, `false`- `1` : fixed sized objects with instance variables - `Point`- `2` : variable sized objects with no instance variables - `Array`- `3` : variable sized objects with instance variables - `Context`- `4` : weak variable sized objects  - `WeakArray`- `5` : weak fixed sized objects with instance variables - `Ephemeron`- `6`, `7`, `8` : unused- `9` : 64 bits indexable- `10 - 11` : 32 bits indexable- `12 - 15` : 16 bits indexable- `16 - 23` : 8 bits indexable- `24 - 31` : compiled methodsZero sized objects are objects that only have a header and does not contain any slots.They are often special objects, among them is `nil`, `true` and `false`.Fixed size object with instance variables represent objects that have a fixed number of slot which is always the same when the memory for the object is allocated.These objects represent classical instances.For example, a `Point` instance is always created with two instance variables `x` and `y`, when the memory is allocated, there will be always two slots for this object.Variable sized objects with no instance variables represent objects that can be allocated with a specific size, regarding the data that are stored inside.Typically, this is the case of `Array` where the memory allocation directly depends on the number of elements that are stored inside.Each element contained in the object is stored as a slot.Consequently, the number of elements of the object is stored by the number of slots in its header.Variable sized objects with instance variables represent objects that can have a specific size during allocation, but which also own dedicated instance variables.This is the case, for example, of `Context`s instances which some instance variables \(`receiver`, `method`...\) and a variable number of temporary variables.The variable array and the instances are all in the slots of the object.As the header of the object only contains the total number of slots, it cannot be used to know where the slots related to the beginning of the array starts.Consequently, the decoding of this object cannot be only done using only the header.The number of instance variables of an instance can be found by going up onto its class.The format of a class imposes that the third slot of a class \(`format`\) is an integer that encodes two pieces of information: the object format needed for the instances \(encoded in the higher part of the integer\) and the number of slot \(encoded in the lower part of the integer\), as shown in the following code example.```caption=Number of instance variables and format of instances is encoded in the class.(Context format & 16rFFFF0000) >> 16>>> 3  "the object format for instances of Context"Context format & 16rFFFF>>> 6  "the number of instance variable for instances of Context"```Weak variable sized objects ... TODOWeak fixed sized objects with instance variables ... TODOIndexable arrays represents objects that encodes multiple raw values on a same slot \(from 1 to 8 depending on if the VM is 32-bits or 64-bits\).More precisely: - 64 bits indexable are only available for 64-bits VM and can stores one 64 bits raw value by slot.- 32 bits indexable are only available for 64-bits VM and can store up to two 32 bits raw values by slot.- 16 bits indexable can store up to two 16 bits raw values by slot for 32-bits VM and four 16 bits raw values by slot for 64-bits VM.- 8 bits indexable can store up to four 8 bits raw values by slot for 32-bits VM and eight 8 bits raw values by slot for 64-bits VM.Each different format indicates how many "non used" values there is on the last slot of the object:- format 10 indicates that there is no "unused" part of the last slot. - format 11 indicates that there is one "unused" part of the last slot, meaning that the last 32 bits raw value is located in the higher part of the last slot and that the lower part is not used.- format 12 indicates that there is no "unused" par of the last slot.- format 13 indicates that there is one "unused" part of the last slot.- format 14 indicates that there is two "unused" parts of the last slot.- ...- format 23 indicates that there is seven "unused" parts of the last slot.The number of elements contained in an object can then be computed by the knowing the number of slots and the object format.For example, for an object of `15` slots with format 18 on a 32 bits VM, we know it has `4` values by slot, then we can compute that it has `(15 * 4) - 3 = 57` values. For more examples, check `ByteArray` \(8 bits\), `WordArray` \(32 bits unsigned integers\).See ShortRunArray, RunArray implementations and uses.Compiled methods objects represents different kind of compiled methods.This kind of object will be detailed later in the document.### Summary of the Spur Memory ModelSpur's design is made to work on both on 32 and 64 bits. The following table summarizes it.| Architecture | 1 word size | Bytes | Header size | Alignment \(object padding\) |  || 32 bits | 32 bits | 4 bytes | 64 bits | 64 bits |  || 64 bits | 64 bits | 8 bytes | 64 bits | 64 bits |  |In both 32 and 64-bits, header size is 64 bits and every object is 64-bits aligned.In 32-bits, some padding is added to ensure this alignment.Immediates objects such as `SmallInteger`s and `Character`s are represented as tagged values.In 64 bits, there is one more immediate object type: `SmallFloat`s.### Resources- Spur [http://www.mirandabanda.org/cogblog/2013/09/05/a-spur-gear-for-cog/](http://www.mirandabanda.org/cogblog/2013/09/05/a-spur-gear-for-cog/)- [https://clementbera.wordpress.com/category/spur/](https://clementbera.wordpress.com/category/spur/)- [https://clementbera.wordpress.com/2018/11/09/64-bits-immediate-floats/](https://clementbera.wordpress.com/2018/11/09/64-bits-immediate-floats/)- [https://clementbera.wordpress.com/2014/01/16/spurs-new-object-format/](https://clementbera.wordpress.com/2014/01/16/spurs-new-object-format/)- [https://clementbera.wordpress.com/2014/02/06/7-points-summary-of-the-spur-memory-manager/](https://clementbera.wordpress.com/2014/02/06/7-points-summary-of-the-spur-memory-manager/)- [http://www.mirandabanda.org/cogblog/category/spur/page/3/](http://www.mirandabanda.org/cogblog/category/spur/page/3/)