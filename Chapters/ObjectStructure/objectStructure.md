## Understanding the Spur Memory ModelBefore delving inside the internals of the VM execution, it is important to understand the data it manipulates, in our case, Pharo objects.This chapter presents in-depth how objects are represented in memory.This will allow us understand in further chapters how are created and mutated, how dynamic type checks are performed and the different memory optimizations employed.The Pharo VM uses since a couple of years the Spur memory model, designed and implemented by Eliot Miranda for the OpenSmalltalk VM\(cite\).This model greatly improved the Garbage Collector \(GC\) and the complexity of JIT-compiled machine code.### BackgroundThis section sets up some terminology necessary to understand this chapter, such as *word*, *nibble* or *alignment*.It is important to set up a common vocabulary because some of these terms are used differently by different technologies, and the Pharo VM terminology is not an exception.#### Data units: Words and bytesObjects are stored in memory, thus it is important to understand the basics of memory organization.Such an organization depends on the chosen computer architecture, which encompasses the memory and the processor.One trait that characterizes a computer architecture and influences strongly the memory organization is its *bit width* *i.e.,* the number of bits used to represent the main processing unit in a processor.For example, 64bit machines are machines with 64bit *width*.Since most common machines nowadays are 64bit machines, we will focus our presentation on them.However, the Pharo VM supports also 32bit machines for compatibility with smaller devices.![Word size and Alignment on 32 and 64 bits architectures.](figures/architecture32vs64.pdf width=100&label=32vs64Architectures)Memory is conceptually divided in cells of 1 byte length, each byte using 8 bits.Data is manipulated in units that group many bytes together.For example, a *word* is a fixed unit of data with as many bits as the processor bit width.This means a word is 64 bits long --or 8 bytes long-- in 64bit processors, and 32 bits long --or 4 bytes long-- in 32bit processors.Figure *@32vs64Architectures@* shows the memory layout on both 32 and 64 bits architectures.The main difference between these two architectures is their word size.Each memory cell has an address represented in a *word*.Note that Figure *@32vs64Architectures@* only shows aligned addresses wheras each 1-byte length cells also have an address.On 64-bits, we may have up to 2^64 different addresses, thus it can address 2^64 different bytes.Representing memory addresses as data is what is commonly referred to as pointers.Processors usually define also concepts such as *half-word*, *double-word*.We believe that such notations are confusing because they require context (Am I in a 32bit architecture? 64bit?), and thus we will not use them in this book.Instead, when referring to a sub-word unit, we will use the exact number of bits.For example, we will use to *16bit integer* instead of *short* or *half-word*.### AlignmentModern architectures and micro-architectures (how CPUs are implemented internally) behave better when data-access patterns are consistent and predictable.One of such access patterns is data alignment, its relative position in memory.A processor's ISA (Instruction Set Architecture) generally provides instructions to perform data reads and writes with different granularity.There are, for example, instructions to read/write individual bytes or entire words.An read/write is said to be aligned when the address is a multiple of the accessed element size, in bytes.1-byte reads are always aligned because all addresses are multiples of 1.8-byte reads are aligned when the address is multiple of 8.We will see later in this chapter how the Pharo VM exploits alignment to implement tagged pointers, and optimize the read of object header meta-data.### Most and least significant bytes and bitsValues is memory are physically stored in order.We say that the **most significant** bit is the bit that has most value in a byte, and conversely for the **least significant** bit.Similarly, we can identify the most and least significant bytes in a word.For example, the bit string 00000101 represents the number 5 in binary, and its least significant bit is represented by the rightest bit with value 1.While we usually represents bytes stored from left-to-right this is only the case of some architectures, which luckily for us, turn out to be the most popular nowadays.The order in which bytes are stored is again a trait of the computer architecture: the endianness.An architecture is said to be little-endian if data bytes are stored from the least signicant to the most significant, and big-endian otherwise.### Object LayoutPharo programs are made of objects which are, for the most part, allocated in memory and occupy space.We call these objects *heap-allocated* because they reside in a memory region managed by the VM called the *heap*, that we will explore in later chapters.#### Heap allocated objects*Heap-allocated* objects in Pharo are represented as a contiguous memory region with space for a header and data slots.The header contains meta-data used for decoding the object internals, such as the size, its type and its class.The data slots contain the data associated to the object such as instance variables and array slots.Each object has a mandatory base header that contains common information such as its class, its size and mutable bits for the Garbage Collector.When objects are more than 254 words long, they are considered large, and their actual size is stored in an extra header that precedes the base header.The base and extra headers have each a fixed size of 8 bytes \(64 bits\).Headers are discussed in-depth in *@formats@*.Data slots represent the different elements/fields in an object and are 1 word long each.Their number depends on the kind of object allocated.Fixed-size classes define a fixed list of instance variables.When a fixed-size class is instantiated (`Person new`), its new instance will have one data slot for each instance variable defined in the class and its superclasses. For example, an instance of the class `Person` defining instance variables `name`, `surname` and `age` has 3 data slots.Variable-size classes, instead, determine the size of their instances dynamically depending on the size of their elements and the number of requested elements.Consider for example the `Array` class, a class whose elements occupy each a word.Allocating such a class with 6 elements (`Array new: 6`) produces an instance of array with 6 elements, thus 6 data slots.There are however other kind of variable-size classes where the element size is different than a word.Those classes will be discussed in *@formats@*.### References and Ordinary Object PointersFrom a Pharo standpoint, an object, whether it is an array, a byte array or a normal `Person` instance, contains references to other objects.Object references, also called *ordinary object pointers*, or *oop*s, are stored and encoded in data slots.In the Pharo VM, there are two kind of oops: pointers to heap-allocated objects and immediate objects.Pointers to heap-allocated objects work as normal pointers in low-level languages.Immediate objects are objects encoded in invalid object pointers using a technique called tagged pointers that takes advantage of pointer alignment.#### Object pointers, Alignment and paddingEvery heap-allocated object in Pharo has an address in memory, which is the memory address of its base header.A heap-allocated object `A` references a heap-allocated object `B` with an absolute pointer to `B`'s base header stored in one if `A`s fields.Figure *@references@* shows two objects forming a cycle. Each object has a single field pointing to the other.References point to the object header.![References to heap-allocated objects are pointers to an object's base header.](figures/references.pdf width=90&label=references)The Pharo VM stores objects aligned to 8 bytes.That is, an object address, and thus its header, is stored always at the 8 byte boundary, regarless of the architecture.Note that since an object header is always 8 bytes long, this means that the first slot of an object is also always aligned.Further, since all slots are a word long, each subsequent slot is also aligned.To guarantee that objects always are aligned to the 8 byte boundary, the allocator inserts a padding at the end of an object when necessary, typically when objects contain slots smaller than 8 bytes as shown in section *@formats@*.Figure *@objectLayout@* shows an example of an how an object with 1 header and 3 slots in laid out both in 32-bits and 64-bits architectures.- in 64-bits, the object occupies 4 words, for a total of 32 bytes. 1 base header of 8 bytes, 3 slots of 1 word each. The next free address \(32 on the Figure\) is aligned and thus an object can start there.- in 32-bits, the object occupies 5 words, for a total of 20 bytes: 1 base header of 2 words \(8 bytes / 4 bytes per word\), 3 slots of 1 word each. The next free address \(20 on the Figure\) is not aligned. In this case, the allocator inserts a 4 byte padding to align the following object to the 8 byte boundary.Although padding represents wasted memory, having the same alignment in all architectures allows an overall code simplification by unifying the 64bit and 32bits implementations.![Object Layout and Alignment on 32 and 64 bits Architectures.](figures/objectLayout.pdf width=90&label=objectLayout)#### Immediate Objects and AlignmentHeap-allocated objects impose a non-negligible overhead on small objects, because of the space take by its header.This problem becomes more visible with types that tend to have a large number of instances.Integers, for example, are in theory infinite, and are used very often by even the simplest programs to drive the execution of loops.Representing integer objects as heap allocated pointers very fast becomes a bottle neck in an application.Instead, Pharo represents integers and other common objects of the kind as tagged pointers.Pointer tagging allows us to represent a large-enough set of values without the need to heap allocate an object, by encoded (and disguising) such values within pointer.Such technique is possible thanks to object alignment.Since all objects are aligned to 8 bytes all object pointers will be multiple of 8 and have the form `xxx...xxx000` in binary, where its 3 lower bits are zero.A tagged pointer is a value that looks like a pointer/address but includes a tag in one of its least significant bits.In case a tag is present, then the value in the most significant bits do not represent a pointer but a value.#### 64-bits Immediate Objects![64 bits immediate objects.](figures/64bitsImmediate.pdf width=100&label=64bitsimm)In 64 bits, immediate objects are: `SmallInteger`s, `Character`s and `SmallFloat`s \(cf. Figure *@64bitsimm@*\).They are also encoded as tagged values \(1 word value\) based on the last "free" 3 bits of addresses because the VM only manipulates object addresses aligned on 8 bytes.`SmallInteger` are encoded on 61 bits \(64 bits minus 3 dedicated to tagging values\).It means that `SmallInteger` immediate objects range is between \[-2^60,2^60-1\].For example: `2r1010001` represents the number `10` \(the immediate value is shifted by three to the right\).```caption=On 64 bits, SmallInteger are encoded on 61 bits.SmallInteger minVal == (2**60) negated>>> trueSmallInteger maxVal == (2**60-1)>>> true```Figure *@64bitsfloatimm@* shows the structure of a `SmallFloat`.![64 bits `SmallFloat` immediate.](figures/64bitsFloatImmediate.pdf width=100&label=64bitsfloatimm)In the VM, `SmallFloat` immediate object works with IEEE double precision floating pointer format.#### 32-bits Immediate Objects![32 bits immediate objects.](figures/32bitsImmediate.pdf width=100&label=32bitsimm)Immediate objects are objects directly encoded in the pointer to the object it points to as tagged values.An immediate object has no object header, no slots and is always 1 word length \(the size of an address\).Figure *@32bitsimm@* shows the possible values of the last 2 bits of an address \(gray cells\):- `00` means that is an aligned address and therefore an object reference in the heap.- `1` tells the VM that it is an immediate `SmallInteger`. This case is special as only the least significant bit is used to mark the tagged value as a `SmallInteger`. It means that the value is encoded on the remaining 31 bits as a signed integer \(in white in the Figure\). The `SmallInteger` immediate objects range is between \[-2^30,2^30-1\]. For example: `2r10101` represents number `10` \(the immediate value is shifted by one to the right\).- `10` tells the VM that it is an immediate `Character` whose value is encoded in the remaining 30 bits \(in white in the Figure\). Having immediate `Character`s makes `String` low-level operations such as `at:` and `at:put:` faster since there is no `Character` instance creation \(`at:put:`\) or extra referencing \(`at:`\). For example: `2r100000110` represents the character `$A` \(`65`\).#### Object Formats*@formats@*Here we should explain different kind of objects. Weak. Byte objects.That there are different kind of slots, and how oops are stored in memory depends on the slot kind.### Class Table and Class IndexesAn object do not store a direct reference to its class but the index of its class in its header.Looking up the class associated to the class index for each message send would clearly be dramatic for the VM efficiency.To mitigate this penalty:- The index of class in the class table is its identity hash. Both the class identity hash and class index are 22 bits length.The additional benefit is that every class has a different identity hash: there is no clash possible.- The class table is a linked list of pages, with a class list on each page.The VM puts most common classes on the first page to avoid walking over all the pages to fetch an object's class.- The class index does not change over time. It means that optimisations such as the inline cache can directly compare class indexes.### Object Header@header#### Base Object Header StructureFor objects that are not immediate, a reference always points to an object's base header.A base object header is 64 bits length, which means it is 2 words in 32 bits and 1 word in 64 bits as shown in Figure *@objectheader@*.![Base Object Header.](figures/ObjectHeader.pdf width=100&label=objectheader)Let us explain the object header structure:- The first left topmost 8 red/orange bits \(marked with an `s`\) represent the number of instance variables \(or slots\) in the object. When an object is created and that it owns more than 254 slots, then an additional 64 bits word is allocated as an header extension. The header extension is allocated before the base object header still, all references to the these point to the address of the base object header. This extension encodes directly the number of slots contained by the object. When an object in memory is decoded, if these 8 bits represent 255, the VM knows that there is an header extension. It then reads the 64 bits word located before the object address and decodes it.- The 22 `h` marked top right light blue bits are for the object identity hash.- The 5 `o` pink bottom left marked bits represent object formats as we will explain later.- The 22 `c` yellow bottom right bits are for the class index. In Spur, there is a class table where each class is given an index. Each object stores in those bits the table index of its class.- The 7 green `X` marked remaining bits are allocated for different reasons:  - 1 bit is reserved for immutability.  - 1 bit is reserved to mark the object as pinned. Basically, a pinned object is an object that cannot be moved in memory by the GC.  - 3 bits are reserved for the GC: isGray \(for tri-color marking\), isRemembered \(for the remembered table from old space to young space\) and isMarked \(for the GC mark phasis\).  - 2 bits are free.#### Extra Object HeaderIn some circumstances, an object may have an extra header word.As explained above, the header of an object encodes its number of slots on one word. Therefore, if an object has more than 255 slots, an extra header is required to encode the number of slots within this object.The optional extra-header is always located before the base header in memory.This layout avoid systematically testing the presence of the extra-header.!!note The address of an object is always the one of its base header regardless if it has an extra header or not.#### Object format@formatsThe object format is represented by the 5 pink bits \(marked with `o`\) of the object header.It encodes the following information:- `0` : 0 sized objects - `nil`, `true`, `false`- `1` : fixed sized objects with instance variables - `Point`- `2` : variable sized objects with no instance variables - `Array`- `3` : variable sized objects with instance variables - `Context`- `4` : weak variable sized objects  - `WeakArray`- `5` : weak fixed sized objects with instance variables - `Ephemeron`- `6`, `7`, `8` : unused- `9` : 64 bits indexable- `10 - 11` : 32 bits indexable- `12 - 15` : 16 bits indexable- `16 - 23` : 8 bits indexable- `24 - 31` : compiled methodsZero sized objects are objects that only have a header and does not contain any slots.They are often special objects, among them is `nil`, `true` and `false`.Fixed size object with instance variables represent objects that have a fixed number of slot which is always the same when the memory for the object is allocated.These objects represent classical instances.For example, a `Point` instance is always created with two instance variables `x` and `y`, when the memory is allocated, there will be always two slots for this object.Variable sized objects with no instance variables represent objects that can be allocated with a specific size, regarding the data that are stored inside.Typically, this is the case of `Array` where the memory allocation directly depends on the number of elements that are stored inside.Each element contained in the object is stored as a slot.Consequently, the number of elements of the object is stored by the number of slots in its header.Variable sized objects with instance variables represent objects that can have a specific size during allocation, but which also own dedicated instance variables.This is the case, for example, of `Context`s instances which some instance variables \(`receiver`, `method`...\) and a variable number of temporary variables.The variable array and the instances are all in the slots of the object.As the header of the object only contains the total number of slots, it cannot be used to know where the slots related to the beginning of the array starts.Consequently, the decoding of this object cannot be only done using only the header.The number of instance variables of an instance can be found by going up onto its class.The format of a class imposes that the third slot of a class \(`format`\) is an integer that encodes two pieces of information: the object format needed for the instances \(encoded in the higher part of the integer\) and the number of slot \(encoded in the lower part of the integer\), as shown in the following code example.```caption=Number of instance variables and format of instances is encoded in the class.(Context format & 16rFFFF0000) >> 16>>> 3  "the object format for instances of Context"Context format & 16rFFFF>>> 6  "the number of instance variable for instances of Context"```Weak variable sized objects ... TODOWeak fixed sized objects with instance variables ... TODOIndexable arrays represents objects that encodes multiple raw values on a same slot \(from 1 to 8 depending on if the VM is 32-bits or 64-bits\).More precisely: - 64 bits indexable are only available for 64-bits VM and can stores one 64 bits raw value by slot.- 32 bits indexable are only available for 64-bits VM and can store up to two 32 bits raw values by slot.- 16 bits indexable can store up to two 16 bits raw values by slot for 32-bits VM and four 16 bits raw values by slot for 64-bits VM.- 8 bits indexable can store up to four 8 bits raw values by slot for 32-bits VM and eight 8 bits raw values by slot for 64-bits VM.Each different format indicates how many "non used" values there is on the last slot of the object:- format 10 indicates that there is no "unused" part of the last slot. - format 11 indicates that there is one "unused" part of the last slot, meaning that the last 32 bits raw value is located in the higher part of the last slot and that the lower part is not used.- format 12 indicates that there is no "unused" par of the last slot.- format 13 indicates that there is one "unused" part of the last slot.- format 14 indicates that there is two "unused" parts of the last slot.- ...- format 23 indicates that there is seven "unused" parts of the last slot.Figure *@multipleBits@* shows how raw 32 bits values are stored in slots for format 10 and 11 with a 64-bits VM.![Taking advantages of multiple bits values for indexable.](figures/32IndexableLastField.png width=100&label=multipleBits)The number of elements contained in an object can then be computed by the knowing the number of slots and the object format.For example, for an object of `15` slots with format 18 on a 32 bits VM, we know it has `4` values by slot, then we can compute that it has `(15 * 4) - 3 = 57` values. For more examples, check `ByteArray` \(8 bits\), `WordArray` \(32 bits unsigned integers\).See ShortRunArray, RunArray implementations and uses.Compiled methods objects represents different kind of compiled methods.This kind of object will be detailed later in the document.#### Bit indexable classes### Summary of the Spur Memory ModelSpur's design is made to work on both on 32 and 64 bits. The following table summarizes it.| Architecture | 1 word size | Bytes | Header size | Alignment \(object padding\) |  || 32 bits | 32 bits | 4 bytes | 64 bits | 64 bits |  || 64 bits | 64 bits | 8 bytes | 64 bits | 64 bits |  |In both 32 and 64-bits, header size is 64 bits and every object is 64-bits aligned.In 32-bits, some padding is added to ensure this alignment.Immediates objects such as `SmallInteger`s and `Character`s are represented as tagged values.In 64 bits, there is one more immediate object type: `SmallFloat`s.### Resources- Spur [http://www.mirandabanda.org/cogblog/2013/09/05/a-spur-gear-for-cog/](http://www.mirandabanda.org/cogblog/2013/09/05/a-spur-gear-for-cog/)- [https://clementbera.wordpress.com/category/spur/](https://clementbera.wordpress.com/category/spur/)- [https://clementbera.wordpress.com/2018/11/09/64-bits-immediate-floats/](https://clementbera.wordpress.com/2018/11/09/64-bits-immediate-floats/)- [https://clementbera.wordpress.com/2014/01/16/spurs-new-object-format/](https://clementbera.wordpress.com/2014/01/16/spurs-new-object-format/)- [https://clementbera.wordpress.com/2014/02/06/7-points-summary-of-the-spur-memory-manager/](https://clementbera.wordpress.com/2014/02/06/7-points-summary-of-the-spur-memory-manager/)- [http://www.mirandabanda.org/cogblog/category/spur/page/3/](http://www.mirandabanda.org/cogblog/category/spur/page/3/)