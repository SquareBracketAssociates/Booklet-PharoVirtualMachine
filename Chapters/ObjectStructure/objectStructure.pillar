!! Understanding Object Structure


!!! About the Spur memory model

The Spur memory model has been designed by Eliot Miranda. Its design is made to work on both on 32 and 64 bits. This chapter is inspired from the blog posts of Clément Béra.

| Architecture | 1 word size | Bytes | Header size | Alignment
| 32 bits | 32 bits | 4 bytes | 64 bits | 32 bits |
| 64 bits | 64 bits | 8 bytes | 64 bits | 64 bits |

In both 32 and 64 bits, every object is 64 bits aligned. However, the object pointer representation is different.

!!!! About alignment

The fact that object addresses are all aligned either on 32 bits or 64 bits (on 64 bits architecture) is an important fact. Indeed some bits are not used to address objects so that they can be used to encode extra information.

For example, when a word is 32 bits (i.e., 4 bytes) all aligned addresses are multiple of 4, meaning that the last two bits are always zero.
In 64 bits (i.e., 8 bytes), the last three bits of an aligned address are zero because it's multiple of 8.

[[[
4 storeStringBase: 2.
>>>  '2r100'
4*17879 storeStringBase: 2.
>>> '2r10001011101011100'
]]]

The virtual machine uses these two bits to encode immediate objects (objects whose value is encoded inside the pointer itself) as we present below.

The fact that objects are aligned to 64 bits also has some consequences for objects whose size is smaller than a word.
For example, a byteString with 17 characters will be composed of a header
and the 17 characters will be allocated in the following bytes. The next object
will not be directly after the characters but on the next multiple of 4.


!!! Immediate objects

Immediate objects are objects directly encoded in the pointer to the object it points to. In 32 bits, immediate objects are SmallIntegers and Characters (see Figure *@32bitsimm*). It means that String accessing low-level operations such as ==at:== and ==at:put:== are faster since there is no Character instance creation (==at:put:==) or extra referencing (==at:==).

In 64 bits, immediate objects are SmallIntegers, Characters and SmallFloats (see Figure *@64bitsimm*).
This is possible since objects are aligned on 64 bits (8 bytes).

+32 bits immediate objects.>figures/32bitsImmediate.pdf|width=100|label=32bitsimm+


+64 bits immediate objects.>figures/64bitsImmediate.pdf|width=100|label=64bitsimm+

!!!! The case of SmallFloat

Figure *@64bitsfloatimm* shows the structure of SmallFloat.

+64 bits immediate floats (SmallFloat).>figures/64bitsFloatImmediate.pdf|width=100|label=64bitsfloatimm+

!!! Object Header

For objects that are not immediate, a reference will point to an object header.
An object header is 64 bits length, which means it is 2 words in 32 bits and 1 word in 64 bits as shown in Figure *@objectheader*.



+Object header.>figures/ObjectHeader.pdf|width=100|label=objectheader+

Let us explain the object header structure:

- The first left topmost 8 red/orange f marked bits represent the number of instance variables (or fields) of the object. When an abject has more than 254 fields, then an additional 64 bits word is allocated as a header extension with the correct size. When the 8 bits represent 255, the VM knows that there is a header extension.
- The 22 h marked top right light blue bits are for the object identity hash.
- The 5 pink bottom left o marked bits represent object formats as we will explain later.
- The 22 c yellow bottom right bits are for the class index. In Spur, there is a class table (managed as pages) where each class is given an index. An object class index is the index of the class in that table.
- The 7 green X marked remaining bits are allocated for different reasons:
-- 1 bit is reserved for immutability.
-- 1 bit is reserved to mark the object as pinned. Basically, a pinned object is an object that cannot move in memory. Usually, objects are moved around by the GC. But not the pinned object. A pinned object will have this bit set.
-- 3 bits are reserved for the GC: isGray (for tri-color marking), isRemembered (for the remembered table from old space to young space) and isMarked (for the GC mark phasis).
-- 2 bits are free.


!!! Object format

The object format is represented by the 5 bits o marked (in pink) of the object header. It encodes the following information.

- 0 : 0 sized object - ==nil==, ==true==, ==false==
- 1 : fixed sized object with instance variables - ==Point==
- 2 : variable sized object with no instance variables - ==Array==
- 3 : variable sized objects with instance variables - ==MethodContext==
- 4 : weak variable sized objects  - ==WeakArray==
- 5 : weak fixed sized objects with instance variables - ==Ephemeron==
- 6, 7, 8 : unused
- 9 : 64 bits indexable
- 10 -11 : 32 bits indexable
- 12 - 15 : 16 bits indexable
- 16 - 23 : 8 bits indexable
- 24 - 31 : compiled methods

The format shows that a format can represent different kinds of indexable arrays: 8, 16, 32  and 64 bits indexable arrays.
This corresponds to ByteArray (8 bits), WordArray (32 bits unsigned integers).  See ShortRunArray, RunArray implementations and uses.


+Taking advantages of multiple bits values for indexable.>figures/32IndexableLastField.png|width=100|label=multipleBits+

Some object formats have several possible bits value. For instance, 32 bits indexable can have 10 or 11 as a bits value. This is because the bit value indicates to the VM where the last slot of the object is in its last word (see Figure *@multipleBits*).


!!! About class index and class table

A header object has its class index. There is a need for extra explanations to understand how the system can access fast to the class of the object.
Indeed looking up the class associated to the class index during each message send is clearly dramatic from a speed perspective. Let us see how this aspect is taken into account:

- A class identity hash is its index in the table. Both the class identity hash and class index are 22 bits length. The additional benefit is that every class has a different identity hash: there is no clash possible.
- Here is how the class message is speed it up.
-- The class table is a linked list of pages, with a class list on each page. Most common classes are put on the first page to avoid walking over all the pages to fetch an object's class.
-- The class index does not change over time. It means that optimisations such as the inline cache can compare directly class index.



!!! Resources

- Spur *http://www.mirandabanda.org/cogblog/2013/09/05/a-spur-gear-for-cog/*
- *https://clementbera.wordpress.com/category/spur/*
- *https://clementbera.wordpress.com/2018/11/09/64-bits-immediate-floats/*
- *https://clementbera.wordpress.com/2014/01/16/spurs-new-object-format/*
- *https://clementbera.wordpress.com/2014/02/06/7-points-summary-of-the-spur-memory-manager/*
- *http://www.mirandabanda.org/cogblog/category/spur/page/3/*
